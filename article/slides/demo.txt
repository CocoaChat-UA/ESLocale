Для начала нам понадобится локаль en_US_POSIX и григорианский календарь.
Они оба создаются очень просто (строки 5, 10). 
Затем мы создаем NSDateFormatter и синхронизируем его локаль и часовой пояс со значениями календаря. Теперь можно подставить необходимый формат даты и корректно преобразовывать строки в дату.

Таким образом, ansiDateFormatter основан на григорианском календаре и локали en_US_POSIX. Дата отсортирована по разрядам от старшего (год) к младшему ( секунды и миллисекунды ).
=========================================================================================================




Теперь рассмотрим sqlite custom function. Как видно, ее сигнатура очень похожа на main(). Единственное отличие в том что возврат результата осуществляется с помощью sqlite3_context, а не директивой return. 
Итак, заглянем под капот. Вначале я делаю проверку количества параметров и распаковку их из массива "argv". Если ваша функция не работает с переменным количеством параметров, то эту проверку сделает за вас SQLite. Далее я преобразую NULL terminated UTF8 строки в NSString. Для экономии ресурсов пользуюсь конструктором, не делающим копию. После этого мы передаем параметры в нужный класс и возвращаем результат ( ну, или ошибку ) через sqlite3_context. При возврате важно передать флаг SQLITE_TRANSIENT, дабы возвращаемая строка была скопирована, а не просто передана как указатель на NSString, который будет удален в autoreleasepool.
Внутри класса, делающего преобразование происходит то, что я описал на слайде.
* создаем  ANSI Formatter
* Преобразуем строку в дату.
* Создаем локаль и NSDateFormatter на ее основе
* задаем формат даты
* преобразуем дату в новую строку
=========================================================================================================








